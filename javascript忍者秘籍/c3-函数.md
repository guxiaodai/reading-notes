# 函数是根基

为什么先讲函数？
因为JavaScript是一门`函数式语言`（functioncal language）

* 函数在javascript中，是`第一型对象`（first-class object）

  由`Function()`构造器创建

  object在JavaScript中拥有的所有功能，函数都拥有，即：
  * 可以通过字面量创建
  * 可以被赋值给变量、数组或其他对象的属性
  * 可以作为函数参数
  * 可以作为函数返回值
  * 可以拥有动态创建并赋值的属性

  与普通对象不同的是，函数可以被调用（invoked）。

* 浏览器的事件轮询

  大多数用户图形界面（GUI）都采用如下方式编写：
    * 创建用户界面
    * 进入轮询，等待事件触发
    * 调用事件的处理程序（监听器）

  浏览器也是如此，不同的是，我们的代码不负责事件的轮询和派发，由浏览器处理。
  事件被触发时被放进一个事件队列（FIFO），然后浏览器调用事件处理程序（handler）。所以handler的调用是异步的。

  需要特别注意的是：浏览器的事件轮询是单线程（single-threaded）的，事件按照队列中的顺序处理。

  回调函数的术语源于：我们定义一个函数，以便其他一些代码在适当的实际回头再调用它。

* 函数声明

  ```javascript
  var canFly = function () {}

  function outer() {
    assert(typeof inner === 'function', "inner() in scope beforDeclaration");
    function inner() {}
  }
  ```
  命名一个函数时，该名称在整个函数声明范围内是有效当，即便提前引用；若声明的是匿名函数并赋值给一个变量，那么提前引用这个变量不能调取到该函数（变量提升）。如：
  ```javascript
  function outer() {
    assert(typeof inner === 'undefined', "inner is not a function now");
    var inner = function () {}
  }
  ```
  一个函数可以存在于定义该函数的整个作用域内，即便提前引用；
  如果一个命名函数声明在顶层，window对象上当同名属性会引用到该函数；
  函数有一个name属性，保存到是该函数名称的字符串，匿名函数的name属性为空字符串。

* 作用域和函数

  在Es6引入块级作用域之前，JavaScript中，作用域由function进行声明，而不是代码块。声明的作用域创建于代码块，而不是终结于代码块。如：
  ```javascript
  if (window) {
    var x = 213;
  }
  alert(x);
  ```
  对于不同的声明，作用域规则的细微差别：
  * 变量声明的作用域，开始于变量声明位置，结束于所在函数的结尾，与代码嵌套无关
  * 命名函数的作用域是指声明该函数的整个函数范围，与代码嵌套无关（也叫机制提升）
  * 对于作用域声明，全局上下文就像一个包含页面所有代码的超大型函数

* 函数调用机制

  函数定义包含4个部分：
  * function 关键字
  * 函数名（可选）
  * () : 存放参数列表
  * {} : 存放函数体

  函数在被调用时，会传递2个隐式参数：arguments和this

  arguments是一个类数组结构的对象，拥有length属性，可以索引取值，存储参数列表

  this参数引用函数被调用时关联的对象，即函数上下文（function context）。说到this，就不得不说下函数的4种调用方式：
  * 作为函数调用：是函数作为方法被调用的一种特殊形式，方法所有者是全局对象，即浏览器中的window。此时this为window对象的引用
  * 作为方法被调用：当函数被赋值给对象的一个属性，并使用引用该函数的这个属性进行调用时，函数就是作为该对象的一个方法被调用。此时this参数为该对象的引用，这个对象成了函数上下文，在函数内部可以以this参数的形式进行访问
  * 作为构造函数进行调用：当函数作为构造函数调用时，会发生如下行为：
    * 创建一个新的空对象
    * 将创建的对象作为this参数传入函数
    * 如果没有显示的返回值，新创建的对象作为返回值返回
  * 使用apply()和call()方法进行调用：显示的指定函数上下文，细粒度的控制函数的调用细节
  
* 箭头函数没有自己的this参数，箭头函数中的this与声明所在的上下文相同
